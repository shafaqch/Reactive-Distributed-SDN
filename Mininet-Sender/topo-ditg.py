#!/usr/bin/python

"""begin comment
Author: Shafaq Chaudhry
Date: Jan - Dec 2020
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


*********** Instructions and Description *************
Description: This file generates the sending agency network, connects to a remote Floodlight controller, and forms a GRE tunnel with teh receiving agency network.
For each host on sending agency, it stars and xTerm and starts and ITGSend, each of which generates <flows> number of flows

Usage: sudo python <filename.py> <controller_ip> <p/r> <mean> <flows> <tau> <numofhosts> <sigma> <u/t> <run_nums>

Explanation of arguments:

<filename.py> is the name of this file

<controller_ip> is the IP of the remote Floodlight controller this network will connect to; Controller port is assumed to be 6653

<p/r> set 'p' for proactive mode and 'r' for reactive mode. Proactive mode will install proactive rules in switch for allowing UDP or TCP traffic depending upon the value of u/t
In the reactive mode, a couple of rules are preconfigured permanent flows to allow ARP, ICMP and D-ITG Signaling 

<mean> mean rate of flow  arrival per unit time

<flows> this is the number of flows per ITG Send that will get generated; so in all the total flows F = <numofhosts> * <flows>

<tau> is the expiration time (idle time out) of reactive rules inserted by Floodlight; this is a parameter here so the log file can be named to include the value of this parameter; not used for any logic in code here

<numofhosts> this is used to generate xTerms on each host and start the ./ITGSend process on each; Each ITGSend will input a script file for multiple flows; Each script file has 50 individual flows

<sigma> this value is to set a limit on number flows in the flow table of the switch if p/r is set to 'r'. When p/r is set to 'p' this has no effect
The code will set flow_limt = sigma + x where x is the number of proactive rules inserted as part of reactive set up.
The overflow policy will impose an eviction of an empheral rule that is close to expiration when flow_limit has been reached.
 


*********** Summary of changes ************
11/4/2020 Added num_runs are parameter, and included in log file names; Changed lambda variable name to mean as that is what it represents in the code
11/5/2020 Changed overflow policy to only be set for reactive UDP case, not reactive TCP case; Changed flow_limit to be sigma + no. of permanent rules in the reactive case. 




endcomment
"""

from mininet.net import Mininet
from mininet.node import Controller, OVSSwitch, RemoteController
from mininet.cli import CLI
from mininet.log import setLogLevel, info
from mininet.term import makeTerms, makeTerm, cleanUpScreens

import sys, subprocess, time


	
def multiControllerNet(argv):

    #argv[0] is the IP address of the controller
    #argv[1] is either p for proactive or r for reactive
    #argv[2] is mean = 1/lambda
    #argv[3] is numofflows
    #argv[4] is expiration timer in floodlight
    #argv[5] is numofhosts to generate
    #argv[6] is sigma for overflow policy
    #argv[7] is either u for udp or t for tcp
    #argv[8] is the number for the run so the log file is generated by the postfix r1, r2, etc.
    strcontroller = argv[0]
    simmode = argv[1] 
    mean=argv[2]
    flows=argv[3]
    tau=argv[4]
    numhosts=argv[5]
    sigma=argv[6]
    udportcp = argv[7]
    numruns = argv[8]
 
    "Create a network from semi-scratch with multiple controllers."

    net = Mininet( controller=Controller, switch=OVSSwitch )

    print "*** Creating (reference) controllers"
 
    # add controller    
    ##c = net.addController( 'c1',controller=RemoteController,ip='192.168.56.102',port=6653) 
    c = net.addController( 'c1',controller=RemoteController,ip=strcontroller,port=6653) 

    print "*** Creating switches with OF10"
    s = net.addSwitch( 's1', protocols="OpenFlow10" )

    print "*** Creating hosts"

    hosts = [ net.addHost('h1',ip='10.0.0.1')]

    # for range from 2 to 11, not including 11 if argv[5] is 10
    for i in range(2,int(argv[5])+1):
	hostname = 'h' + str(i)
	hostip = '10.0.0.' + str(i)
	hosts.append ( net.addHost( hostname,ip=hostip ) )

    print hosts

    print "*** Creating links"
    for h in hosts:
        net.addLink( s, h )
	print "Added link " + s.name + " -> " +h.name


    print "*** Starting network"
    net.build()
    net.start()

    time.sleep(1)

    # configure the GRE tunnel
    print "*** Configuring GRE tunnel ***"
    s.cmd('ovs-vsctl add-port s1 s1-gre1 -- set interface s1-gre1 type=gre '+
       'options:remote_ip=192.168.56.104')
    s.cmdPrint('ovs-vsctl show')

    print "*** Inserting proactive rules for DITG signaling and ARP ***"
    # add proactive rules for DITG signaling on TCP port 9000
    s.cmd('ovs-ofctl add-flow s1 dl_type=0x800,nw_proto=6,tcp_dst=9000,actions=normal')
    s.cmd('ovs-ofctl add-flow s1 dl_type=0x800,nw_proto=6,tcp_src=9000,actions=normal')
    # add proactive rule for ARP and ICMP
    s.cmd('ovs-ofctl add-flow s1 dl_type=0x806,arp_op=1,nw_proto=1,actions=flood')#ARP request broadcast
    s.cmd('ovs-ofctl add-flow s1 dl_type=0x800,icmp_type=8,nw_proto=1,actions=normal')#ICMP echo request
    s.cmd('ovs-ofctl add-flow s1 dl_type=0x800,icmp_type=0,nw_proto=1,actions=normal')#ICMP echo reply
    s.cmd('ovs-ofctl add-flow s1 dl_type=0x806,arp_op=2,actions=normal')#ARP reply unicast

    print "*** Inserted proactve rules for DITG signaling and ARP ***"

    # if 'r' is chosen, then configure overflow policy, else add UDP allow rule for praoctive case
    if simmode == 'r':
	if udportcp == 'u':
		flow_limit = int(sigma) + 6
		# configure overflow-policy only in case of UDP reactive 11/5
		print "*** Configuring overflow policy ***"
		strEvict = "ovs-vsctl -- --id=@ft create Flow_Table flow_limit="+str(flow_limit)+" overflow_policy=evict groups='\"NXM_OF_IN_PORT[]\"' -- set Bridge s1 flow_tables:0=@ft"
		s.cmd(strEvict)
	
    elif simmode == 'p':
	if udportcp == 'u':
	        print "*** Configuring UDP proactive rule ***"

		# configure UDP proactive rule to allow all UDP traffic
	    	s.cmd('ovs-ofctl add-flow s1 dl_type=0x800,nw_proto=17,actions=normal')
	else: 
		print "*** Configuring TCP proactive rules***"
		# configure TCP proactive rule to allow all bi-directional TCP traffic
	    	s.cmd('ovs-ofctl add-flow s1 dl_type=0x800,nw_proto=6,actions=normal')
    else:
	print "either r or p expected as simmode"

    print "*** Testing network"
    net.pingAll()

    # wait a bit before starting xterms
    print "*** Waiting to start xterms***"
    #time.sleep(5)

    print "*** Starting xTerms"
    i=1
    port = 50001

    print hosts
    for h in hosts:
	
	#sendlog = "send" + h.name + ".log"
	#recvlog = "recv" + h.name + ".log"
	print h
	destip = "10.0.1." + str(i)
	#destport = str(port)
	if udportcp == 'u':
		flowfilename = "multiflowu-"+mean+"-"+flows+"-"+destip
		sendlog = "su-"+simmode+"-m"+mean+"-f"+flows+"-x"+numhosts+"-t"+tau+"-s"+sigma+"-h"+str(i)+"-b"+str(i)+"-r"+numruns
		recvlog = "ru-"+simmode+"-m"+mean+"-f"+flows+"-x"+numhosts+"-t"+tau+"-s"+sigma+"-h"+str(i)+"-b"+str(i)+"-r"+numruns

	else:
		flowfilename = "multiflowt-"+mean+"-"+flows+"-"+destip
		sendlog = "st-"+simmode+"-m"+mean+"-f"+flows+"-x"+numhosts+"-t"+tau+"-s"+sigma+"-h"+str(i)+"-b"+str(i)+"-r"+numruns
		recvlog = "rt-"+simmode+"-m"+mean+"-f"+flows+"-x"+numhosts+"-t"+tau+"-s"+sigma+"-h"+str(i)+"-b"+str(i)+"-r"+numruns

	print flowfilename + " " + sendlog + " " + recvlog
        #poisson -O <mean> WORKS!
	#cmdstr = "bash -c '~/D-ITG-2.8.1-r1023-src/D-ITG-2.8.1-r1023/bin/ITGSend -a 10.0.1."+str(i)+" -rp " + destport + " -O 30 -c 10 -T UDP -t 60000 -l sendh"+str(i)+".log -x recvh"+str(i)+".log;'"
	#poisson -O <mean> with script for multiple flows between source and destination

	#the following works only if run in the DITG bin directory
	#cmdstr = "bash -c './ITGSend multiflowu-30-50-10.0.1.1 -l sendh"+str(i)+".log -x recvh"+str(i)+".log;'"

	cmdstr = "bash -c './ITGSend " +flowfilename+ " -l " +sendlog+ " -x " +recvlog+ " ;'"
#	cmdstr = "bash -c 'ping -c  10.0.1.1;'"
#        print cmdstr
	#constant -C <packets/sec> WORKS!
	#cmdstr = "bash -c '~/D-ITG-2.8.1-r1023-src/D-ITG-2.8.1-r1023/bin/ITGSend -a 10.0.1."+str(i)+" -rp " + destport + " -C 100 -c 10 -T UDP -t 60000 -l sendh"+str(i)+".log -x recvh"+str(i)+".log;'"
	
	term = makeTerm(h, cmd=cmdstr)
	#term = makeTerm(h, cmd="bash -c './ITGSend "+flowfilename+" -l sendlog -x recvlog;'")
#-a 10.0.1.1 -T UDP -O 20 -c 512 -t 120000 -l sendlog -x recvlog;'")
	net.terms.append( term )
#	net.terms.append(makeTerm(h,cmd="bash -c 'ping -c 10.0.1.1;'"))
	i += 1
	#port +=1

    #if test1 is specified or no test is specified, run SimpleHTTPServer on h2
    #h2 = net.hosts[1]
    #print "*** Starting SimpleHTTPServer on host " + h2.name
    #print h2.cmd('python -m SimpleHTTPServer 80 &')
    #time.sleep(1)

    net.terms += makeTerms (net.switches, 'switch')
    #net.terms += makeTerms (net.hosts, 'host')

    print "*** Running CLI"
    CLI( net )

    print "*** Stopping network"
    net.stop()

if __name__ == '__main__':
    setLogLevel( 'info' )  # for CLI output

    if (len(sys.argv)) < 10:
        print "Usage: <filename.py> <controller_ip> <p/r> <mean> <flows> <tau> <numofhosts> <sigma> <u/t> <run_nums>"
        quit()

    print "*** clear previous mininet topologies ***"
    
    bashCommand = "sudo mn -c"
    process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE)
    output, error = process.communicate()

    multiControllerNet(sys.argv[1:])
